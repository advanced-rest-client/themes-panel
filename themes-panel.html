<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu-light.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-item/paper-item-body.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../openable-panel-behavior/openable-panel-behavior.html">
<link rel="import" href="../paper-toast/paper-toast.html">
<!--
A panel to display themes installed in the application.

The element is an UI for themes logic in the application. It does not contain
logic to activate or discovery themes. It communicates with the application (model)
via custom events. See events description for more information. Note that most events
have to be cancelled.

Once the element is "opened" it queries for list of available themes, if it wasn't
already. When the list of themes changes call `refreshThemes()` on the element
to update list of themes in the UI.

### Example
```
<themes-panel></themes-panel>
```

## Theme model

Model for the `Theme` object is similar to `package.json` data model.

The object consist with the following properties:

- **name** `{String}` Theme name
- **main** `{String}` Theme main file in the theme main directory
- **path** `{String}` Absolute location of the theme on user's filesystem. If the location is relative then default theme location is used.
- **description** `{String}` Theme short description.

### Styling
`<themes-panel>` provides the following custom properties and mixins for styling:

Custom property | Description | Default
----------------|-------------|----------
`--themes-panel` | Mixin applied to the element | `{}`
`--arc-font-headline` | Mixin applied to the header | `{}`
`--arc-font-subhead` | Mixin applied to the subheader | `{}`
`--error-toast` | Mixin applied to the error toast | `{}`
`--empty-info` | Mixin applied to the label rendered when no data is available. | `{}`
`--warning-primary-color` | Main color of the warning messages | `#FF7043`
`--warning-contrast-color` | Contrast color for the warning color | `#fff`

@group UI Elements
@element themes-panel
@demo demo/index.html
-->
<dom-module id="themes-panel">
  <template>
    <style>
    :host {
      display: block;
      @apply --themes-panel;
    }

    header {
      @apply --layout-horizontal;
      @apply --layout-center;
    }

    h2 {
      @apply --arc-font-headline;
      @apply --layout-flex;
    }

    h3 {
      @apply --arc-font-subhead;
    }

    .error-toast {
      background-color: var(--warning-primary-color, #FF7043);
      color: var(--warning-contrast-color, #fff);
      @apply --error-toast;
    }
    </style>
    <header>
      <h2>Themes</h2>
    </header>
    <paper-dropdown-menu-light label="Active theme">
      <paper-listbox class="dropdown-content" selected="{{activeTheme}}" attr-for-selected="data-id" on-selected-changed="_selectionChanged">
        <template is="dom-repeat" items="[[themes]]">
          <template is="dom-if" if="[[item.hasDescription]]">
            <paper-item data-id$="[[item._id]]" label="[[item.name]]">
              <paper-item-body two-line>
                <div>[[item.name]]</div>
                <div secondary>[[item.description]]</div>
              </paper-item-body>
            </paper-item>
          </template>
          <template is="dom-if" if="[[!item.hasDescription]]">
            <paper-item data-id$="[[item._id]]">[[item.name]]</paper-item>
          </template>
        </template>
      </paper-listbox>
    </paper-dropdown-menu-light>
    <section class="theme-editor">
      <h3>Theme editor</h3>
      <p>You can create new theme or edit currently activated in the application theme.</p>
      <p>Learn more about editing theme in Advanced REST Client in <a href="https://github.com/advanced-rest-client/arc-electron/wiki/Creating-theme-for-Advanced-REST-Client" target="_blank" on-tap="_openThemeDoc">our documentation</a>.</p>
      <div>
        <paper-button raised on-tap="_openEditor" data-action="create-theme">Create theme</paper-button>
        <paper-button raised on-tap="_openEditorCurrent" data-action="edit-theme">Edit active theme</paper-button>
      </div>
    </section>
    <paper-toast id="noModel" text="Model not found. Please, report an issue." class="error-toast"></paper-toast>
    <paper-toast id="noSelection" text="Theme is not activated. Select theme and try again." class="error-toast"></paper-toast>
    <paper-toast id="errorToast" class="error-toast"></paper-toast>
  </template>
  <script>
  Polymer({
    is: 'themes-panel',

    behaviors: [ArcBehaviors.OpenablePanelBehavior],

    properties: {
      /**
       * List of themes.
       */
      themes: Array,
      // ID of selected theme. The ID is generated by `computeThemeId()`.
      activeTheme: String
    },

    observers: [
      '_updateThemes(_isOpened)'
    ],

    _updateThemes: function(_isOpened) {
      if (!_isOpened) {
        return;
      }
      if (!this.themes) {
        Polymer.RenderStatus.afterNextRender(this, this.refreshThemes);
      }
    },
    /**
     * Generates an ID from theme object to be used internally to recognize a
     * theme object.
     *
     * @param {Object} theme The theme object. See element description for data model
     * @return {String} Unique ID of the theme.
     */
    computeThemeId: function(theme) {
      var id = theme.name + '|' + theme.main + '|' + theme.path;
      return id;
    },
    /**
     * Dispatches `themes-list` custom event to query model for the list of
     * available themes.
     * The event must be cancelled when handled (`e.preventDefault()`).
     * The list of themes should be returned as a Promise added to the `result`
     * property of the `detail` object of the event.
     */
    refreshThemes: function() {
      var e = this.fire('themes-list', {}, {
        cancelable: true,
        composed: true
      });
      if (!e.defaultPrevented) {
        this.$.noModel.opened = true;
        return;
      }
      e.detail.result
      .then(themes => {
        themes = themes || [];
        themes = themes.map(i => {
          i = Object.assign({}, i);
          i._id = this.computeThemeId(i);
          i.hasDescription = !!i.description;
          return i;
        });
        this.set('themes', themes);
        this.getActiveTheme();
      })
      .catch(cause => this._handlePromiseError(cause));
    },
    /**
     * Dispatches `theme-active-info` custom event to query model for currently
     * activated theme. The model should always return theme info object, even
     * if it's a default object.
     *
     * The theme info object should be returned as a Promise added to the `result`
     * property of the `detail` object of the event.
     */
    getActiveTheme: function() {
      var e = this.fire('theme-active-info', {}, {
        cancelable: true
      });
      if (!e.defaultPrevented) {
        this.$.noModel.opened = true;
        return;
      }
      e.detail.result
      .then(theme => {
        if (!theme) {
          console.error('Current theme info not available.');
          return;
        }
        let id = this.computeThemeId(theme);
        this.__cancelChange = true;
        this.set('activeTheme', id);
        this.__cancelChange = false;
      })
      .catch(cause => this._handlePromiseError(cause));
    },

    _handlePromiseError: function(cause) {
      this.$.errorToast.text = cause.message;
      this.$.errorToast.opened = true;
      this.fire('send-analytics', {
        type: 'exception',
        description: cause.message || 'Theme data loading error',
        fatal: false
      });
      console.error(cause);
    },

    _openThemeDoc: function(e) {
      var ev = this.fire('open-theme-doc', {}, {
        cancelable: true
      });
      if (ev.defaultPrevented) {
        e.preventDefault();
      }
    },

    _openEditor: function() {
      this.fire('theme-editor-create');
    },

    _openEditorCurrent: function() {
      var id = this.activeTheme;
      if (!id) {
        this.$.noSelection.opened = true;
        return;
      }
      var info = this.themes.find(i => i._id = id);
      if (!info) {
        this.$.noSelection.opened = true;
        return;
      }
      this.fire('theme-editor-edit', {
        theme: info
      });
    },

    _selectionChanged: function(e) {
      if (this.__cancelChange) {
        return;
      }
      var id = e.detail.value;
      var info = this.themes.find(i => i._id = id);
      if (!info) {
        this.$.noSelection.opened = true;
        return;
      }
      this.fire('theme-activate', {
        theme: info
      });
    }

    /**
     * Dispatched when the element requests to list currently installed themes.
     * The event is cancelable and the model must cancel the event when handling
     * it. Otherwise the element will ignore the result and display error.
     *
     * The result should be a Promise resolved to a list of `Theme` objects.
     * See element description for data model. The promise must be set on `result`
     * property of the `detail` object.
     *
     * ## Example
     * ```javascript
     * e.preventDefault();
     * e.detail.result = Promise.resolve({...});
     * ```
     *
     * @event themes-list
     */

    /**
     * Dispatched when the element requests information about currently
     * activated theme.
     *
     * The element does not assume default theme. This event should always result
     * with a theme info object.
     *
     * The event is cancelable and the model must cancel the event when handling
     * it. Otherwise the element will ignore the result and display error.
     *
     * The result should be a Promise resolved to a `Theme` objects.
     * See element description for data model. The promise must be set on `result`
     * property of the `detail` object.
     *
     * ## Example
     * ```javascript
     * e.preventDefault();
     * e.detail.result = Promise.resolve({...});
     * ```
     *
     * @event theme-active-info
     */

    /**
     * Dispatched when the user requested to open documentation for theme editor.
     * If handled the event must be cancelled. Otherwise default action is performed
     * (click on the link).
     *
     * @event open-theme-doc
     */

    /**
     * Dispatched when the user requested to run theme editor to create a new
     * theme.
     *
     * @event theme-editor-create
     */

    /**
     * Dispatched when the user requested to run theme editor to edit installed
     * theme.
     *
     * @event theme-editor-edit
     * @param {Object} theme The theme infor object. See element description for
     * morel information.
     */

    /**
     * Dispatched when the user selected a theme to be activated.
     *
     * @event theme-activate
     * @param {Object} theme The theme infor object. See element description for
     * morel information.
     */
  });
  </script>
</dom-module>
